use crate::concrete::ConcreteTerm as Term;

grammar;

pub Term: Term = {
    "(" <l:Term> ")" ":" <r:Term> => Term::Annot(l.into(), r.into()),
    "\\" <v:Var> "." <t:Term> => Term::Lam(v, t.into()),
    App => <>,
    <l:App> "->" <r:Term> => Term::UnnamedPi(l.into(), r.into()),
    "(" <v:Var> ":" <l:Term> ")" "->" <r:Term> => Term::Pi(v, l.into(), r.into()),
    "let" <v:Var> "=" <l:Term> "in" <r:Term> => Term::Let(v, l.into(), r.into()),
    "let" <v:Var> ":" <l:Term> "in" <r:Term> => Term::Decl(v, l.into(), r.into()),
    <l:App> "," <r:Term> => Term::Pair(l.into(), r.into()),
    <App> ".1" => Term::First(<>.into()),
    <App> ".2" => Term::Second(<>.into()),
    <l:App> "*" <r:Term> => Term::UnnamedSigma(l.into(), r.into()),
    "(" <v:Var> ":" <l:Term> ")" "*" <r:Term> => Term::Sigma(v, l.into(), r.into()),
    "case" <a:CaseAnnot> <s:Term> "of" <cs:List<Case, "|">> => Term::Case(s.into(), a, cs),
    "case" "[" <c:Term> "]" <p:Term> "of" "refl" "(" <v:Var> ")" "->" <t:Term> => Term::EqElim(c.into(), p.into(), v, t.into()),
    "ucase" "[" <v:Var> "." <ty:Term> "]" <u:Term> "of" "unit" "->" <t:Term> => Term::UnitElim(v, ty.into(), u.into(), t.into()),
    <x:App> "=" <y:App> ":" <ty:App> => Term::EqTy(x.into(), y.into(), ty.into()),
    "~" <a:Var> "." "\\" <x:Var> "." <tm:Term> => Term::Rec(a, x, tm.into()),
};

CaseAnnot: Option<(String, Box<Term>)> = {
    "[" <v:Var> "." <t:Term> "]" => Some((v, t.into())),
    () => None,
};

List<T, U>: Vec<T> = {
    <v:(<T> U)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            let mut v = v;
            v.push(e);
            v
        }
    }
};

Case: (String, String, Term) = {
    "<" <Var> "=" <Var> ">" "->" <App> => (<>),
};

Sum: (String, Term) = {
    <Var> ":" <Term> => (<>),
}

App: Term = {
    <l:App> <r:Atom> => Term::App(l.into(), r.into()),
    Atom => <>,
};

Atom: Term = {
    "(" <Term> ")" => <>,
    "<" <v:Var> "=" <t:Term> ">" => Term::Variant(v, t.into()),
    "<" <List<Sum, "+">> ">" => Term::Enum(<>),
    "fold" <Atom> => Term::Fold(<>.into()),
    "unfold" <Atom> => Term::Unfold(<>.into()),
    "fix" <Atom> => Term::Fix(<>.into()),
    "Type" => Term::Type,
    "unit" => Term::Unit,
    "Unit" => Term::UnitTy,
    "refl" => Term::Refl,
    Var => Term::Var(<>),
};

Var: String = {
    r"[a-zA-Z0-9'_]+" => <>.to_string(),
};