let Void = <> in
let void_elim = (\A.\v.case v of) : (A : Type) -> Void -> A in


let Nat = (~n.\u.<zero : Unit + succ : n u>) : Unit -> Type in
let 0 = (fold(<zero = unit>)) : Nat unit in
let succ = (\n.fold(<succ = n>)) : Nat unit -> Nat unit in
let 1 = succ 0 in let 2 = succ 1 in
let plus = (fix (\f.\m.\n. case unfold m of <zero = x> -> n | <succ = m'> -> succ (f m' n))) : Nat unit -> Nat unit -> Nat unit in

let foo = (refl) : (plus 1 1 = 2) in

unit

fix (\f. (\m. (\n. case unfold(m) of <zero = x> -> n | <succ = m'> -> ((\n. fold(<succ = n>)) ((f m') n)))))
((\n. fold(<succ = n>)) fold(<zero = unit>))


((\n. fold(<succ = n>)) fold(<zero = unit>))




and ((\n. fold(<succ = n>)) ((\n. fold(<succ = n>)) fold(<zero = unit>)))