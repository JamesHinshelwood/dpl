let Nat = (~n.\u.(l : {zero | succ}) * (case l of zero -> Unit | succ -> n u)) : Unit -> Type in
let 0 = (fold('zero, unit)) : Nat unit in
let succ = (\n.fold('succ, n)) : Nat unit -> Nat unit in
let 1 = succ 0 in let 2 = succ 1 in
let plus = (fix (\f.\m.\n. let (l, r) = unfold m in case l of zero -> n | succ -> succ (f r n))) : Nat unit -> Nat unit -> Nat unit in

let Vec = (\A.~v.\n.(l : {nil | cons}) * (case l of nil -> (n = 0) | cons -> ((m : Nat unit) * A * v m * (n = succ m)))) : Type -> (Nat unit) -> Type in
let nil = (\A.fold('nil, refl)) : (A : Type) -> Vec A 0 in
let cons = (\A.\a.\n.\v.fold('cons, (n, a, v, refl))) : (A : Type) -> A -> (n : Nat unit) -> Vec A n -> Vec A (succ n) in
let head = (\A.\n.\v.(let (l, r) = unfold v in case l of cons -> (let (m, ave) = r in (let (a, ve) = ave in a)))) : (A : Type) -> (n : Nat unit) -> Vec A (succ n) -> A in

let taib = (\A.\k.\n.\v.\p.let (l, r) = unfold v in case l of cons -> (let (m, awe) = r in (let (a, we) = awe in (let (w, e) = we in w)))) : (A : Type) -> (k : Nat unit) -> (n : Nat unit) -> Vec A k -> (k = succ n) -> Vec A n in
let tail = (\A.\n.\v.taib A (succ n) n v refl) : (A : Type) -> (n : Nat unit) -> Vec A (succ n) -> Vec A n in

unit