let Nat = (~n.\u.(b : {zero | succ}) * (case b of zero -> Unit | succ -> n u)) : Unit -> Type in
let 0 = (fold('zero, unit)) : Nat unit in
let succ = (\n.fold('succ, n)) : Nat unit -> Nat unit in
let plus = (fix (\f.\m.\n. let (l, r) = unfold m in case l of zero -> n | succ -> succ (f r n))) : Nat unit -> Nat unit -> Nat unit in
let 1 = succ 0 in let 2 = succ 1 in let 3 = succ 2 in let 4 = succ 3 in

let And = (\A.\B.(A * B)) : (A : Type) -> (B : Type) -> Type in
let Or = (\A.\B.((l : {left | right}) * (case l of left -> A | right -> B))) : (A : Type) -> (B : Type) -> Type in

let even = (~e.\n.(l : {Z | SS}) * (case l of Z -> (n = 0) | SS -> ((m : (Nat unit)) * e m * (n = succ (succ m))))) : (Nat unit) -> Type in
let ev_0 = (fold('Z, refl)) : even 0 in
let ev_SS = (\n.\e.fold('SS, (n, e, refl))) : (n : Nat unit) -> even n -> even (succ (succ n)) in
let ev_4 = (ev_SS 2 (ev_SS 0 ev_0)) : even 4 in
let ev_plus4 = (\n.\e.ev_SS (plus 2 n) (ev_SS n e)) : (n : Nat unit) -> even n -> even (plus 4 n) in
let ev_inversion = (\n.\e.let (l, r) = unfold e in case l of Z -> ('left, r) | SS -> ('right, )) : (n : Nat unit) -> even n -> Or (n = 0) ((m : Nat unit) * And (n = succ (succ m)) (even m)) in

unit